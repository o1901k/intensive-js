```
1) Какие бывают алгоритмы сортировок ? 
Пузырьковая сортировка - проходит по массиву несколько раз и на каждом этапе перемещая самое большое значение из неотсортированных в конец массива.
Сортировка вставками работает, проходя по массиву и перемещая нужное значение в начало массива. 
Сортировка выбором - гибрид между пузырьковой и сортировкой вставками. Проходит по массиву несколько раз, перемещая наименьшее значение в начало массива. 
Сортировка слиянием - разделяем массив пополам до тех пор, пока каждый участок не станет длиной в один элемент, затем они сливаются в правильном порядке.
Быстрая сортировка - состоит из трёх шагов. Сначала выбирается опорный элемент. Затем другие элементы в массиве перераспределяют так, чтобы элементы меньше опорного оказались до него, а большие или равные — после. А дальше применяют первые два шага к подмассивам справа и слева от опорного значения.

2) Прочитать про "Операторы и выражения, циклы в JS"
&& (И) -  true, если оба аргумента истинны, а иначе – false. 
Т.е. при проверке возвращает первое ложное значение. Или последнее, если ничего не найдено.
|| (ИЛИ) если какой-либо из аргументов true,  вернёт true, иначе возвращается false.
Т.е. при проверке возвращает первое истинное значение или последнее, если такое значение не найдено.
! (НЕ) - приводит к булевому типу и возвращает противоположное значение.
?? (оператор нулевого слияния) - возвращает первое значение, если оно определено (не null/undefined), иначе вернет второе.
Цикы:
- while (условие) {тело цикла} Проверяется условие на истинность и выполняется тело, если true. Если ложно выполнение останавливается.
- do {тело цикла} while (условие) Сначала выполняет тело, а затем проверяется условие. Выполняется пока его значение равно true.
- for (начало; условие; шаг) {тело цикла}Цикл выполняет тело, пока условие true.
for (key in object) {тело цикла} Проходит по всем перечисленным свойствам объекта (включая свойства, унаследованные от прототипа).
for(char of text){тело цикла} Проходит только по значениям элементов объекта. Позволяет перебирать итерируемые объекты(массивы, строки и др.)

3) Создать объект Person несколькими способами, после создать объект Person2, чтобы в нём были доступны методы объекта Person. Добавить метод logInfo чтоб он был доступен всем объектам.

const Person = {
name: ‘Alex’,
surname: ‘Smith’,
};

const Person = Object.create({});
Person.name = 'Alex';
Person.surname = 'Smith';

const Person = Object.assign({}, {name: 'Alex', surname: 'Smith'});

const Person2 = Object.create(Person) 

const Person2 = {} 
Object.setPrototypeOf(Person2, Person)

Person.logInfo = function () {
return `${this.name} ${this.surname}`
}

console.log(Person2.logInfo())

4) Создать класс PersonThree c get и set для поля name и конструктором, сделать класс наследник от класса Person.
class PersonThree {
constructor (name) {
this.name = name;
}
get name () {
return this._name;
}
set name (value) {
this._name = value;
}
}

class PersonThree extends Person {}


БОНУС: 
1) Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total:

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
total = 13;
//result = [4, 9]

const firstSum = (arr, total) => {
       let result = [];
  for (let i = 0; i < arr.length; i++) {
  for (let j= i + 1; j < arr.length; j++) {
  if(arr[i] + arr[j] === total) {
  result.push(arr[i]);
  result.push(arr[j]);
  }
  }
  }
  return result.slice(0, 2);

}

firstSum(arr,total)

2) Какая сложность у вашего алгоритма ?
O(n^2)
