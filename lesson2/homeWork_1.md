1. Метод запроса OPTIONS.

Метод OPTIONS позволяет запросить информацию о сервере. Ответ на запрос содержит Allow заголовок с поддерживаемыми методами. Также в заголовке ответа может включаться информация о поддерживаемых расширениях.
Используется, в основном, механизмом Preflight request в CORS (Совместное использование ресурсов между источниками).
Передается в формате: OPTIONS URL HTTP/2

2. Ключевые особенности "HTTP" Версии 3.0

HTTP/3 главное отличие от предыдущих версий в том, что она использует новый транспортный протокол QUIC и передаёт данные быстрее.
QUIC — транспортный протокол, работающий поверх UDP. Передаёт данные быстрее TCP, тратит меньше времени на установку соединения, но при этом такой же надёжный.
HTTP/3 использует QUIC на транспортном уровне и уровне безопасности. QUIC заменяет TCP и TLS.
Помимо QUIC, HTTP/3 отличается от HTTP/2 тем, что имеет другой алгоритм сжатия заголовков и исключает некоторые функции (например, мультиплексирование), так как их уже содержит QUIC.
HTTP/3 лучше реализовывает мультиплексирование. Если в HTTP/2 при потере TCP-пакета вся передача данных останавливалась до восстановления пропажи, то в HTTP/3 информация продолжает передаваться.

3.  Способы отмены запроса.

Можно отменить запрос с помощью cancelToken. Необходимо создать переменную, которая будет источник отмены.
cancelToken = axios.CancelToken и source = CancelToken.source.
Внутри запроса передаем токен созданной переменной cancelToken: source.token
Запускаем отмену в нужном месте с использованием source.cancel().


Для fetch есть похожее api — AbortController. Сначала создаем controller через new AbortController(). Затем отслеживаем signal через controller.signal.
При получении сигнала используем controller.abort();

4. Примеры создания примитивных значений (string, number, boolean, null, undefined, symbol, bigInt).

let str = ‘string 1’ или “string 2” или `string ${1+2}`;
let str2 = new String(‘’);

let num = 5;
let num2 = new Number(5)

let bool = true;
let bool2 = new Boolean(true);

let null1 = null;

let undef; // при вызове выведет undefined
let undefined2 = undefined;

let symbol1 = Symbol(“id”)
let symbol2

let bigInt = 1523n;
let bigInt2 = new BigInt(1523);

5. Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError?

Мы получаем ошибку из-за временной мертвой зоны (temporal dead zone). TDZ начинается в начале области видимости переменной и заканчивается ее объявлением.

6. Решить: 
const res = "B" + "a" + (1 - "hello");
console.log(res); // "BaNaN"
Т.к. 1 - "hello" возвращает NaN, а все остальные операции конкатинация строк, то вернется "BaNaN"

const res2 = (true && 3) + "d";
console.log(res2); // “3d”
Оператор && ищет и возвращает первое ложное значение, либо последнее(в данном случае 3). После конкатинация строк - "3d"

const res3 = Boolean(true && 3) + "d";
console.log(res3); // “trued”
Оператор && вернет 3 и затем Boolean() преобразует к true и затем конкатинация строк - "trued"

